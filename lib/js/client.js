phantom.injectJs("phantom.js");/** * PhantomJS Client class  */function Client(totalTimeout, loadFinishedTreshold, activityTimeout, finishTimeout) {	if (!(this instanceof arguments.callee)) {		return new Client(totalTimeout, loadFinishedTreshold, activityTimeout, finishTimeout);	}	var cli = this;		this.requestStart = null;	this.requestEnd = null;	this.resources = {};	this.navigable = [];	this.page = new WebPage();	this.callback = null;	this.shouldIgnoreNextLoadError = false;	this.finalUrl = '';		this.totalTimeoutTimer = null;	this.totalTimeout = totalTimeout;	this.loadFinishedTreshold = loadFinishedTreshold;	this.activityTimeout = activityTimeout; 	this.finishTimeout = finishTimeout; 	this.totalTime = function() {		return this.requestEnd - this.requestStart;	};		this.invokeCallback = function(status, info) {		this.callback.call(this, { 'status' : status, 'info' : info, 'duration': this.totalTime() });	};		/**	 * set a decent viewport size before starting to load	 */	this.correctViewport = function() {		var h = this.page.viewportSize.height;		var w = this.page.viewportSize.width;		if (h < 768) { h = 768; }		if (w < 1024) { w = 1024; }		this.page.viewportSize = { width: w, height: h };	};		/**	 * look for the bigest iframe in terms of scrollable area	 */	this.getMaxIFrameSize = function() {		var ifs = this.page.evaluate(function() {			var iframes = document.querySelectorAll('iframe'), sizes = [];			for (var i = 0, l = iframes.length, f; i < l; ++i) {				if ((f = iframes[i]) === null) continue;				sizes.push({'w': f.scrollWidth, 'h': f.scrollHeight, 'a': (f.scrollWidth*f.scrollHeight)});			}			return sizes;		});		var maxFrame = null;		for (var i=0, l=ifs.length, s; i<l; ++i) {			s=ifs[i];			if (maxFrame == null || maxFrame.a < s.a) { maxFrame = s; }		}		return maxFrame;	}		this.getPageSize = function() {		return this.page.evaluate(function() { 			return { 'w': document.body.scrollWidth, 'h': document.body.scrollHeight }; 		});	};		this.getViewSize = function() {		var maxFrame = this.getMaxIFrameSize();		var pageSize = this.getPageSize();				var w = maxFrame == null ? pageSize.w : Math.max(pageSize.w, maxFrame.w);		var h = maxFrame == null ? pageSize.h : Math.max(pageSize.h, maxFrame.h);		return { 'width' : w, 'height' : h };	};	/**	 * adapt the viewport size to the height of the actual loaded page	 */	this.adaptViewport = function() {		var s = this.getViewSize();		debug("correcting size to : " + s.width + "x" + s.height);		this.page.viewportSize = s;	};		this.recordResource = function(resource) {		if (this.resources[resource.id]) {			warn("resource with id '" + id + "' already exists, ignoring");		} else {			this.resources[resource.id] = resource;		}	};		this.getResource = function(id) {		return this.resources[id];	};		this.getResourcesCount = function() {		return Object.keys(this.resources).length	};		this.page.onUrlChanged = function(url) {		cli.finalUrl = url;		print({ 'type': 'message', 'message': url});	};		this.page.onNavigationRequested = function(url, type, will, main) {		if (!will) {			cli.navigable.push(url);		}		//debug("NAVIGATION_REQUEST. url=" + url + " type=" + type + " accept=" + will + " main=" + main);	};		this.page.onAlert = function(msg) {		debug("JS-ALERT: " + JSON.stringify(msg));	};		this.page.onConsoleMessage = function(msg) {		debug("JS-CONSOLE: " + JSON.stringify(msg));	};		this.page.onError = function(msg) {		debug("JS-ERROR: " + JSON.stringify(msg));	};		this.page.onConfirm = function(msg) {		debug("JS-CONFIRM: " + JSON.stringify(msg));		return true;	};		this.page.onPrompt = function(msg, defaultValue) {		debug("JS-PROMPT: " + JSON.stringify(msg) + ", " + JSON.stringify(defaultValue));		return defaultValue;	};	this.page.onResourceRequested = function(r) {		if (r.canceled) debug("[>>](c:" + r.canceled + "-" + r.hitCount + ") " + r.url);		var resource = new Resource(r.id, r.method, r.time, r.url, r.headers, cli.resources);		cli.recordResource(resource);	};		this.page.onResourceReceived = function(r) {		// reset the timeouts		cli.resourcesLoadThrottler.reset();		var resource = cli.getResource(r.id);		if (resource) {			if (r.stage == "start") {				resource.responseStart(r);			} else if (r.stage == "end") {				resource.responseEnd(r);								// bugfix for errors when requesting HTTPS				if (resource.isHttps && resource.status === null && resource.isDoc === false) {					//debug("____https failure bug workaround (1)");					cli.shouldIgnoreNextLoadError = true;				}							} else {				warn("got unexpected response stage : '" + r.stage + "', ignoring");			}		} else {			warn("got response for unknown resource '" + r.id + "', ignoring");		}				//debug("[<<](" + r.stage + ") " + r.url);	};		/**	 * garantees that the callback will be called only once	 * after no new resources have been received for more than	 * delay ms or nothing has happened for timeout ms.	 */	this.waitForResources = function(delayMs, callback, activityTimeout, finishTimeout, noStart) {		this.resourcesLoadThrottler = new Throttler(delayMs, callback, activityTimeout, finishTimeout, noStart);	};		this.page.onInitialized = function() {				// hack 'Math.random'		cli.page.evaluate(function() {			Math.random = function() { return 49 / 100; };		});				// hack 'addEventListener'		try {			var path = phantom.libraryPath + "/big-ears.js";			var fn = "(function() {\r\n " + require('fs').read(path) + "\r\n bigEars = new BigEars(); \r\n })";			cli.page.evaluate(eval(fn));		} catch(e) { console.log("ERROR while wrapping 'addEventListener' : " + e); }				// hack 'Date.getTime' and 'Date.now'		cli.page.evaluate(function() {			_FANTOMAS_date_locked = false;			_FANTOMAS_start_date = Date.now();			_FANTOMAS_date_ref = _FANTOMAS_start_date;			_FANTOMAS_date_getTime = Date.prototype.getTime;			_FANTOMAS_date_now = Date.now;			Date.now = function() { 				return _FANTOMAS_date_locked ? _FANTOMAS_date_ref : _FANTOMAS_date_now.apply(this, arguments);			};			Date.prototype.getTime = function() {				return _FANTOMAS_date_locked ? _FANTOMAS_date_ref : _FANTOMAS_date_getTime.apply(this, arguments);			};		});	};		this.lockDate = function(lock, time) {		var l = cli.page.evaluate(function(lock, time) {			_FANTOMAS_date_locked = lock;			_FANTOMAS_date_ref = (time !== undefined) ? time : _FANTOMAS_start_date;			return _FANTOMAS_date_locked;		}, lock, time);		debug("date locked : " + l);	};		this.fireUXListeners = function(reverse) {		return cli.page.evaluate(function(reverse) {			return bigEars.fireListeners([				'click', 'dblclick', 'keyup', 'keydown', 'mousedown', 'mouseup', 				'change', 'blur', 'focus', 'select', 'submit'			], reverse);		}, reverse);	};		this.getLoadDiagnostic = function() {		var keys = Object.keys(this.resources);		if (keys.length == 0) return "NO_REQUEST";		var s = "", r;		for (var i=0, l=keys.length; i<l; ++i) {			r = this.resources[keys[i]];			s += r.status + "[" + (r.isDoc ? "doc" : "res") + ":" + (r.isCompleted() ? "ok" : "wait") + "] ";			if ((!r.url.startsWith("data") && r.status == null) || (parseInt(r.status)) >= 400) {				s += "<-(" + r.url + ") " 			}		}		return s;	};		this.getUnfinishedResources = function() {		var keys = Object.keys(this.resources), r, i, l;		var unfinished = [];		for (i=0, l=keys.length; i<l; ++i) {			r = cli.resources[keys[i]];			if (!r.isCompleted()) { unfinished.push(r); }		}		return unfinished;	};		this.clearTotalTimeout = function() {		if (this.totalTimeoutTimer !== null) {			clearTimeout(this.totalTimeoutTimer);		}	};		this.resetTotalTimeout = function() {		this.clearTotalTimeout();		this.totalTimeoutTimer = setTimeout(			function() { 				debug("total timeout");				cli.invokeCallback('timeout', { 'type' : 'total-timeout', 'delay': cli.totalTimeout });			}, 			cli.totalTimeout*1000		);	};		this.getFinalUrl = function() {		return this.finalUrl; 	};		this.open = function(url, callback, headers) {		if (headers === undefined) { headers = {}; }		this.url = url;		this.finalUrl = url;		this.callback = callback;		this.resources = {};			var finishCallback = function(pageStatus) {			cli.requestEnd = Date.now();			cli.clearTotalTimeout();						if (this.timeout) {				cli.invokeCallback('timeout', { 'type' : this.type, 'delay' : this.delay });			} else if (pageStatus === 'success') {				cli.invokeCallback('success', 'http://www.youtube.com/watch?v=roxqTOAor0I');			} else {				warn("failed to open '" + cli.url + "'");				cli.invokeCallback('load_error', { 'page' : pageStatus });			}		};			this.resetTotalTimeout();		this.waitForResources(			this.loadFinishedTreshold*1000, 			finishCallback, 			this.activityTimeout*1000, 			this.finishTimeout*1000		);				this.correctViewport();		this.requestStart = Date.now();		this.page.customHeaders = headers;				this.page.open(url, function(status) {			if (cli.shouldIgnoreNextLoadError === true && status == 'fail') {				//debug("____https failure bug workaround (2)");				cli.shouldIgnoreNextLoadError = false;				return;			}						/**			 * This function is often called multiple times in a row.			 * A treshold was added so that the actual onLoadFinished is called			 * only after ((page.onLoadFinished was called once) AND ((page.onLoadFinished OR 			 * page.onResourceRequested) were called LOAD_FINISHED_TRESHOLD seconds ago)).			 */			//debug("onload");			cli.resourcesLoadThrottler.start(status);		});	};};