phantom.injectJs("phantom.js");  /** * Resource classes * * id: the unique id of the resouce for a page * method: the request method (POST, GET) * requestTime: the unix time at which the request was made * url: the url of the resource * requestHeaders: the request sent by the browser for this resource * resources: the current page's list of resources (used to find out if the resource is a document or not)  *  */function Resource(id, canceled, method, requestTime, url, requestHeaders, resources) {  if (!(this instanceof arguments.callee)) {    return new Resource(id, method, requestTime, url, requestHeaders, resources);  }  this.id = id;  this.canceled = canceled;  this.method = method;  this.requestTime = requestTime;  this.responseStartTime = null;  this.responseEndTime = null;  this.url = url;  this.requestHeaders = requestHeaders;  this.responseHeaders = {};  this.status = null;  this.redirectURL = null;  this.isHttps = url.startsWith("https");  this.isDoc = this._isDoc(id, url, resources);}Resource.prototype._isDoc = function(id, url, resources) {  // resource "1", the first request, is the base document  if (id == "1") { return true; }  var keys = Object.keys(resources);  for (var i=0, l=keys.length; i<l; ++i) {    var r = resources[keys[i]];    if (!r.redirectURL) continue;    if (r.isDoc && r.redirectURL == url) {      // if a document was a redirection to this resource's url, then this resouce is a document too       return true;    }  }  return false;};Resource.prototype.responseStart = function(r) {  this.responseStartTime = r.time;  this.responseHeaders = r.headers;  this.status = r.status;    // read redirection url  var redir = this.readHeader(r.headers, 'Location');  if (redir) {	if (redir[0] === '/') {	  // make redirectURL absolute      var server = this.url.substr(0, this.url.indexOf('/', "https://".length));      this.redirectURL = server + redir;    } else {     this.redirectURL = redir;    }  }};  Resource.prototype.responseEnd = function(r) {  if (this.responseStartTime === null) {    // response end with no response start : there is no response body    this.responseStart(r);  }  this.responseEndTime = r.time; // Date.now()    // debug("resource END id:" + this.id + " doc:" + this.isDoc + " https:" + this.isHttps + " status:" + this.status   //+ " url:" + this.url  // );};Resource.prototype.responseTime = function() {  return this.responseStartTime - this.requestTime;};  Resource.prototype.isCompleted = function() {  return this.responseEndTime !== null;};  Resource.prototype.downloadTime = function() {  return this.responseEndTime - this.responseStartTime;};  Resource.prototype.totalTime = function() {  return this.responseEndTime - this.requestTime;};  Resource.prototype.isRedir = function() {  return this.status == "301" || this.status == "302";};  Resource.prototype.readHeader = function(headers, key, ignoreCase) {  if (ignoreCase === undefined) { ignoreCase = true; }  if (ignoreCase === true) { key = key.toUpperCase(); }  var i, l, h, hk;  for (i=0, l=headers.length; i<l; i++) {    h = headers[i];    if (!h) continue;    hk = ignoreCase ? h.name.toUpperCase() : h.name;    if (hk == key) { return h.value; }  }  return undefined;};  Resource.prototype.toString = function() {  return "" + (this.isDoc ? "{DOC}" : "{REQ}") + "[" + this.status + "] '" + this.id +   "' (response: " + this.responseTime() + "ms, download: " + this.downloadTime() + "ms, total: " + this.totalTime() + "ms)" +   (this.isRedir() ? " -> " + this.redirectURL : " R: " + this.url);};