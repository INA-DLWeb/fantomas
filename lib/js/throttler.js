phantom.injectJs("phantom.js");/** * Event Throttler * * delayMs: after the first call to 'start', the maximum time that we will  * wait without 'start' OR 'reset' before invoking the callback. * * callback: the callback that we will invoke. * * activityTimeoutMs: the maximum time that we will wait for the _first_ call * to 'start' OR 'reset' before invoking the callback. * * finishTimeoutMs: the maximum time that we will wait or the _first_ call to * 'start' before invoking the callback. * * noStart: reset() and start() become equivalent. The fist call to any of * these will start throttling. * */function Throttler(throttleMs, callback, activityTimeoutMs, finishTimeoutMs, noStart) {  if (!(this instanceof arguments.callee)) return new Throttler(throttleMs, callback, activityTimeoutMs, finishTimeoutMs, noStart);  var t = this;    this.done = false;  this.noStart = (noStart === true);    this.callback = callback;  this.callbackArguments = null;    this.throttleMs = throttleMs;  this.throttleTimer = undefined;        this.activityTimeoutMs = activityTimeoutMs;  this.activityTimeoutTimer = undefined;    this.finishTimeoutMs = finishTimeoutMs;  this.finishTimeoutTimer = undefined;    this.cancelTimer = function(timer) {    if (timer) {      clearTimeout(timer);      return true;    }    return false;  };    /**   * isTimeout: if true, firing this timer will result in a timeout failure.   * type     : the name of the timer   * delay    : the time to wait before invoking the callback   * timer    : the timer ID of the timer to reset (optional)   */  this.startOrResetTimer = function(isTimeout, type, delay, timer) {    var wasStarted = this.cancelTimer(timer);    //debug((wasStarted ? "re" : "") + "starting a timer. timeout:" + isTimeout + ", type:" + type + " delay:" + delay);    var cb = function() {      if (t.done) return;      debug("finish : had no '" + type + "' after waiting for '" + delay + "' ms");      t.done = true;       t.cancel();      t.callback.apply({'timeout': isTimeout, 'type': type, 'delay': delay}, t.callbackArguments);     };    return setTimeout(cb, delay);  };    this.activityTimeoutTimer = this.startOrResetTimer(true, 'firstActivity', this.activityTimeoutMs, this.activityTimeoutTimer);  this.finishTimeoutTimer = this.startOrResetTimer(true, 'firstFinish', this.finishTimeoutMs, this.finishTimeoutTimer);    // create a timer that will run the callback if start/hit is not called for "delay" milliseconds  this.start = function() {    this.throttle(true, arguments);  };    // restart an existing timer (noop if not started yet (unless noStart))  this.reset = function() {    this.throttle(this.noStart, arguments);  };    // if a timer is currently running, cancel it  this.cancel = function() {    this.cancelTimer(this.throttleTimer);    this.cancelTimer(this.activityTimeoutTimer);    this.cancelTimer(this.finishTimeoutTimer);  };    this.throttle = function(createIfNotExist, callbackArguments) {    if (this.done) {       //debug("throttler: done already");       return;    }    	// if we are going to start the throttler, cancel the finish timer    if (createIfNotExist) {      this.cancelTimer(this.finishTimeoutTimer);    }        // if we have an activity timeout timer, cancel it    this.cancelTimer(this.activityTimeoutTimer);        // if the throttle timer is already running, cancel it.    this.cancelTimer(this.throttleTimer);        if (callbackArguments !== undefined && callbackArguments.length > 0) {      this.callbackArguments = callbackArguments;      //debug("ARGS:" + this.callbackArguments + " [" + this.callbackArguments.length + "]");    };        // if we want to "create a timer if none exist", or if one already existed, start a new timer.    if (this.throttleTimer !== undefined || createIfNotExist) {      this.throttleTimer = this.startOrResetTimer(false, 'moreActivity', this.throttleMs, this.throttleTimer);    }  }; }